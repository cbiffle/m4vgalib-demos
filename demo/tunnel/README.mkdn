Old-skool tunnel effect.

Note that this is built at two different resolutions.  Try 'em both.

This demonstrates:

 - Repeating pixels to effectively lower resolution, saving memory and compute
   time.  In this case, pixels are handled in 2x2 groups, reducing 800x600 to
   an effective resolution of 400x300, or 640x480 to 320x240.

 - Subsampling a lookup table in ROM, and then upsampling it at runtime using
   bilinear interpolation, to save space.

 - Using half-precision floating point to store precomputed tables more
   cheaply.

 - Stupid (but *really useful*) constexpr tricks for generating lookup tables
   at compile time and putting them in ROM.

 - Rendering tricks handed down through the ages.


Notes
=====

This demo uses a bunch of tricks.

First: it uses a lookup table to avoid calling `atan2` or `sqrt` during
rendering.  This lookup table is generated by a `constexpr` routine in
`table.cc`, so it runs *entirely inside the compiler*.  The results are just
as if you had typed them in by hand, and can (and do!) go into ROM.

Second: the lookup table only describes one quarter of the screen, because
that's enough for `atan2`.  We can generate the rest of the screen using
basic trig identities.

Third: the lookup table is subsampled, with each entry describing a 4x4
doubled-pixel area (so 8x8 monitor pixes).  This dramatically reduces the size
of the table.  We linearly interpolate between table entries to make up for the
missing data.  It's technically wrong, but it looks fine.

Fourth: the lookup table is further compacted by being stored in half-precision
floating point.

Fifth: we only actually draw the *top half* of the screen.  We use a special
rasterizer to mirror and reverse the top of the screen onto the bottom half
during scanout.  This makes two pages of 8-bit framebuffer just barely
possible, since (at 800x600) we're storing a 400x150 framebuffer instead of
400x300.

All that processing is using about 60% of the available CPU.  Increasing the
`config::sub` parameter raises the interpolation block size to 8x8, reduces the
CPU usage to 33%, but makes the tunnel in the distance appear slightly square.
Tradeoffs.

Moving from 400x300 to 800x600 would be difficult: you would not have room for
a framebuffer (at least in color), so you'd have to generate the pixels during
scanout with a rasterizer.  Unfortunately, to get the vertical resolution
increase, you'd need to generate the pixels -- and thus perform the table
lookups and linear interpolation -- for every scanline.  Without a breakthrough
in the algorithm or implementation, this would be computationally infeasible.

Because the 640x480 version has fewer pixels to push and a higher ratio of CPU
cycles to pixel clock cycles, it's only using about 38% of the CPU.
